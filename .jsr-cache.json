{"package":"@hongminhee/aitertools","version":"0.6.0","index":{"Range":{"kind":[{"char":"c","kind":"Class","title":"Class"},{"char":"c","kind":"Class","title":"Class"}],"name":"Range","file":".","doc":"An immutable sequence of numbers.  It implements both `Iterable` and\n`AsyncIterable`.\n\nIt is similar to Python's `range()` function.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range","deprecated":false,"label":"Range"},"new Range":{"kind":[{"char":"c","kind":"Class","title":"Class"},{"char":"c","kind":"Class","title":"Class"}],"name":"Range","file":".","doc":"An immutable sequence of numbers.  It implements both `Iterable` and\n`AsyncIterable`.\n\nIt is similar to Python's `range()` function.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range#constructors","deprecated":false,"label":"new Range"},"new Range()":{"kind":[{"char":"c","kind":"Class","title":"Class"},{"char":"c","kind":"Class","title":"Class"}],"name":"Range","file":".","doc":"An immutable sequence of numbers.  It implements both `Iterable` and\n`AsyncIterable`.\n\nIt is similar to Python's `range()` function.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range#constructors","deprecated":false,"label":"new Range"},"Range.length()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.length","file":".","doc":"The length of the range.  Note that it guarantees to return the same value\nas `Array.from(range).length`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconsole.log(range(10, -10, -3.5).length);\n```\n\nThe above example will print `6`.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length","deprecated":false,"label":"Range.length()"},"~Range.length()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.length","file":".","doc":"The length of the range.  Note that it guarantees to return the same value\nas `Array.from(range).length`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconsole.log(range(10, -10, -3.5).length);\n```\n\nThe above example will print `6`.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length","deprecated":false,"label":"length()"},"Range.length":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.length","file":".","doc":"The length of the range.  Note that it guarantees to return the same value\nas `Array.from(range).length`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconsole.log(range(10, -10, -3.5).length);\n```\n\nThe above example will print `6`.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length","deprecated":false,"label":"Range.length"},"~Range.length":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.length","file":".","doc":"The length of the range.  Note that it guarantees to return the same value\nas `Array.from(range).length`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconsole.log(range(10, -10, -3.5).length);\n```\n\nThe above example will print `6`.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length","deprecated":false,"label":"length"},"Range.[Symbol.iterator]()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.iterator]","file":".","doc":"Iterates over the elements of the range.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4n)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]","deprecated":false,"label":"Range.[Symbol.iterator]()"},"~Range.[Symbol.iterator]()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.iterator]","file":".","doc":"Iterates over the elements of the range.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4n)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]","deprecated":false,"label":"[Symbol.iterator]()"},"Range.[Symbol.iterator]":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.iterator]","file":".","doc":"Iterates over the elements of the range.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4n)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]","deprecated":false,"label":"Range.[Symbol.iterator]"},"~Range.[Symbol.iterator]":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.iterator]","file":".","doc":"Iterates over the elements of the range.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4n)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]","deprecated":false,"label":"[Symbol.iterator]"},"Range.[Symbol.asyncIterator]()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.asyncIterator]","file":".","doc":"Iterates over the elements of the range, in an asynchronous manner.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor await (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]","deprecated":false,"label":"Range.[Symbol.asyncIterator]()"},"~Range.[Symbol.asyncIterator]()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.asyncIterator]","file":".","doc":"Iterates over the elements of the range, in an asynchronous manner.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor await (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]","deprecated":false,"label":"[Symbol.asyncIterator]()"},"Range.[Symbol.asyncIterator]":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.asyncIterator]","file":".","doc":"Iterates over the elements of the range, in an asynchronous manner.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor await (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]","deprecated":false,"label":"Range.[Symbol.asyncIterator]"},"~Range.[Symbol.asyncIterator]":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.[Symbol.asyncIterator]","file":".","doc":"Iterates over the elements of the range, in an asynchronous manner.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor await (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]","deprecated":false,"label":"[Symbol.asyncIterator]"},"Range.at()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.at","file":".","doc":"Returns the element at the specified index in the range.  Note that it\nguarantees to return the same value as `Array.from(range).at(index)`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconst r = range(10, -10, -3.5);\nconsole.log(r.at(3), r.at(-1));\n```\n\nThe above example will print the following 2 lines:\n\n~~~\n-0.5\n-7.5\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at","deprecated":false,"label":"Range.at()"},"~Range.at()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.at","file":".","doc":"Returns the element at the specified index in the range.  Note that it\nguarantees to return the same value as `Array.from(range).at(index)`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconst r = range(10, -10, -3.5);\nconsole.log(r.at(3), r.at(-1));\n```\n\nThe above example will print the following 2 lines:\n\n~~~\n-0.5\n-7.5\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at","deprecated":false,"label":"at()"},"Range.at":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.at","file":".","doc":"Returns the element at the specified index in the range.  Note that it\nguarantees to return the same value as `Array.from(range).at(index)`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconst r = range(10, -10, -3.5);\nconsole.log(r.at(3), r.at(-1));\n```\n\nThe above example will print the following 2 lines:\n\n~~~\n-0.5\n-7.5\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at","deprecated":false,"label":"Range.at"},"~Range.at":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.at","file":".","doc":"Returns the element at the specified index in the range.  Note that it\nguarantees to return the same value as `Array.from(range).at(index)`.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nconst r = range(10, -10, -3.5);\nconsole.log(r.at(3), r.at(-1));\n```\n\nThe above example will print the following 2 lines:\n\n~~~\n-0.5\n-7.5\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at","deprecated":false,"label":"at"},"Range.toString()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.toString","file":".","doc":"Represents the range as a string.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString","deprecated":false,"label":"Range.toString()"},"~Range.toString()":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.toString","file":".","doc":"Represents the range as a string.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString","deprecated":false,"label":"toString()"},"Range.toString":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.toString","file":".","doc":"Represents the range as a string.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString","deprecated":false,"label":"Range.toString"},"~Range.toString":{"kind":[{"char":"m","kind":"Method","title":"Method"}],"name":"Range.prototype.toString","file":".","doc":"Represents the range as a string.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString","deprecated":false,"label":"toString"},"Range.start":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.start","file":".","doc":"The start of the range.  It must be a finite number.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.start","deprecated":false,"label":"Range.start"},"~Range.start":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.start","file":".","doc":"The start of the range.  It must be a finite number.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.start","deprecated":false,"label":"start"},"Range.stop":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.stop","file":".","doc":"The stop of the range.  It must be a finite number.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.stop","deprecated":false,"label":"Range.stop"},"~Range.stop":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.stop","file":".","doc":"The stop of the range.  It must be a finite number.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.stop","deprecated":false,"label":"stop"},"Range.step":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.step","file":".","doc":"The step of the range.  It must be a finite number, and cannot be zero.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.step","deprecated":false,"label":"Range.step"},"~Range.step":{"kind":[{"char":"p","kind":"Property","title":"Property"}],"name":"Range.prototype.step","file":".","doc":"The step of the range.  It must be a finite number, and cannot be zero.","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.step","deprecated":false,"label":"step"},"assertStreamStartsWith()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"assertStreamStartsWith","file":".","doc":"Makes an assertion that the beginning elements of the `actual` iterable are\nin common with the elements of the `expected` array.\n\n``` typescript\nimport { assertStreamStartsWith } from \"./testing.ts\";\nimport { count } from \"./infinite.ts\";\n\nDeno.test(\"your test name\", async () => {\n  const stream = count(0, 5);\n  await assertStreamStartsWith(stream, [0, 5, 10, 15]);\n});\n```\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/assertStreamStartsWith","deprecated":false,"label":"assertStreamStartsWith()"},"assertStreams()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"assertStreams","file":".","doc":"Makes an assertion that the elements of the `actual` iterable are equal to\nthe elements of the `expected` array.\n\n``` typescript\nimport { assertStreams } from \"./testing.ts\";\n\nasync function* gen() { yield \"actual\"; yield \"elements\"; }\n\nDeno.test(\"your test name\", async () => {\n  const stream = gen();\n  await assertStreams(stream, [\"actual\", \"elements\"]);\n});\n```\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/assertStreams","deprecated":false,"label":"assertStreams()"},"concat()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"concat","file":".","doc":"Concatenates multiple async iterables into one async iterable.\n\n``` typescript\nimport { concat } from \"./concat.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = concat(gen(), [\"a\", \"b\", \"c\", \"d\"]);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 8 lines:\n\n~~~\nfoo\nbar\nbaz\nqux\na\nb\nc\nd\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/concat","deprecated":false,"label":"concat()"},"count()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"count","file":".","doc":"Makes an infinite async iterable of evenly spaced values starting with\nthe `start` number.\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nconst iterable = count(5);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n5\n6\n7\n8\n9\n(...)\n~~~\n\nYou could adjust the interval by passing a second argument to `count()`:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nconst iterable = count(0, 3);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n0\n3\n6\n9\n12\n(...)\n~~~\n\nAs it's infinite, it's usually used with `break` to stop the iteration:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nfor await (const value of count(0)) {\n  if (value > 4) break;\n  console.log(value);\n}\n```\n\nOr with other async generators like `takeWhile()`:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nimport { takeWhile } from \"./take.ts\";\nfor await (const value of takeWhile(count(0), v => v <= 4)) {\n  console.log(value);\n}\n```\n\nThe both examples above will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/count","deprecated":false,"label":"count()"},"cycle()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"cycle","file":".","doc":"Makes an async iterator that yields elements from the `source` and saving\na copy of each.  When the `source` is exhausted, yields saved copies\nindefinitely.\n\nNote that it may require significant memory to save the copies\ndepending on the length of the `source`.\n\n``` typescript\nimport { cycle } from \"./infinite.ts\";\n\nasync function* gen() { yield 3; yield 6; yield 9; }\nconst iterable = cycle(gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n3\n6\n9\n3\n6\n9\n(...)\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/cycle","deprecated":false,"label":"cycle()"},"drop()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"drop","file":".","doc":"Drops a specified number of elements from the beginning of an async iterable,\nand yields the remaining elements.\n\n``` typescript\nimport { drop } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = drop(gen(), 2);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbaz\nqux\n~~~\n\nIf the iterable is shorter than or equal to the specified number, no elements\nare yielded.\n\n``` typescript\nimport { drop } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = drop(gen(), 4);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print nothing.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/drop","deprecated":false,"label":"drop()"},"dropEnd()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"dropEnd","file":".","doc":"Drops a specified number of elements from the end of an async iterable, and\nyields the remaining elements.\n\n``` typescript\nimport { dropEnd } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropEnd(gen(), 2);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nbar\n~~~\n\nIf the iterable is shorter than or equal to the specified number, no elements\nare yielded.\n\n``` typescript\nimport { dropEnd } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropEnd(gen(), 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print nothing.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/dropEnd","deprecated":false,"label":"dropEnd()"},"dropWhile()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"dropWhile","file":".","doc":"Drops elements from the beginning of an async iterable as long as a specified\ncondition is met, and yields the remaining elements.\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), v => v !== \"baz\");\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbaz\nqux\n~~~\n\nAn async `predicate` function also works.  The following example will print\nthe same 2 lines as the previous example:\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), v => Promise.resolve(v !== \"baz\"));\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nA `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), (_, i) => i % 2 === 0);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 3 lines:\n\n~~~\nbar\nbaz\nqux\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/dropWhile","deprecated":false,"label":"dropWhile()"},"filter()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"filter","file":".","doc":"Eliminates all elements from the iterable `source` that do not satisfy\nthe `predicate` function.\n\n``` typescript\nimport { filter } from \"./filter.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = filter((v: string) => !!v.match(/^b/), gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbar\nbaz\n~~~\n\nThe `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { filter } from \"./filter.ts\";\n\nconst iterable = filter(\n  (v: string, i: number) => !v.match(/^b/) && i % 2 === 0,\n  [\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]\n);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nquux\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/filter","deprecated":false,"label":"filter()"},"fromIterable()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"fromIterable","file":".","doc":"Turns a synchrnous iterable `source` into an async iterable.\n\n``` typescript\nimport { fromIterable } from \"./collections.ts\";\n\nfunction* iterable() { yield 1; yield 2; yield 3; }\nconst asyncIterable = fromIterable(iterable());\nfor await (const value of asyncIterable) console.log(value);\n```\n\nThe above example will print the following lines:\n\n~~~\n1\n2\n3\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/fromIterable","deprecated":false,"label":"fromIterable()"},"groupBy()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"groupBy","file":".","doc":"Groups elmenets of an async interable `source` according to a specified\n`keySelector` function and creates a map of each group key to the elements in\nthat group.  Key values are compared using the `===` operator.\n\n``` typescript\nimport { groupBy } from \"./unique.ts\";\n\ninterface IdName { id: number; name: string; }\nasync function* gen(): AsyncIterableIterator<IdName> {\n  yield { id: 1, name: \"foo\" };\n  yield { id: 2, name: \"bar\" };\n  yield { id: 3, name: \"bar\" };\n  yield { id: 4, name: \"foo\" };\n}\n\nconst map = await groupBy<string, IdName>(gen(), o => o.name);\nconsole.log(map);\n```\n\nThe above example will print the following:\n\n~~~\nMap {\n \"foo\" => [ { id: 1, name: \"foo\" }, { id: 4, name: \"foo\" } ],\n \"bar\" => [ { id: 2, name: \"bar\" }, { id: 3, name: \"bar\" } ]\n}\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/groupBy","deprecated":false,"label":"groupBy()"},"map()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"map","file":".","doc":"Transforms every element of the iterable `source` into a new iterable.\n\n``` typescript\nimport { map } from \"./map.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = map((v: number) => v * 2, count());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n0\n2\n4\n6\n(...)\n~~~\n\nThe `fn` function can take an additional argument, which is the index of the\nelement in the iterable.\n\n``` typescript\nimport { map } from \"./map.ts\";\n\nconst iterable = map(\n  (v: string, i: number) => `${i}. ${v.toUpperCase()}`,\n  [\"foo\", \"bar\", \"baz\", \"qux\"]\n);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0. FOO\n1. BAR\n2. BAZ\n3. QUX\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/map","deprecated":false,"label":"map()"},"range()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"range","file":".","doc":"Creates a {@link Range} of numbers from 0 to `stop` with step 1.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n\nNote that the type of the range is `Range<number>`, which implements\nboth `Iterable<number>` and `AsyncIterable<number>`.\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/range","deprecated":false,"label":"range()"},"reduce()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"reduce","file":".","doc":"Apply `reducer` function of two arguments cumulatively to the elements of\nan async iterable `source`, from left to right, so as to reduce the async\niterable to a single value.\n\n``` typescript\nimport { reduce } from \"./fold.ts\";\n\nasync function* oneToFive() { yield 1; yield 2; yield 3; yield 4; yield 5; }\nconst reducedValue = await reduce(\n  (x, y) => { console.log(`${x} + ${y} = ${x + y}`); return x + y; },\n  oneToFive(),\n  0,\n);\nconsole.log(\"reduced value:\", reducedValue);\n```\n\nThe above example will print the following:\n\n~~~\n0 + 1 = 1\n1 + 2 = 3\n3 + 3 = 6\n6 + 4 = 10\n10 + 5 = 15\nreduced value: 15\n~~~\n\nIf the async iterable `source` is empty, the `reducer` function is not\ncalled and `initialValue` is returned.\n\n``` typescript\nimport { reduce } from \"./fold.ts\";\n\nconst reducedValue = await reduce(\n  (x, y) => { console.log(`${x} + ${y} = ${x * y}`); return x * y; },\n  [],\n  1,\n);\nconsole.log(\"reduced value:\", reducedValue);\n```\n\nThe above example will print the following:\n\n~~~\nreduced value: 1\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/reduce","deprecated":false,"label":"reduce()"},"repeat()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"repeat","file":".","doc":"Makes an async iterator that yields the same value over and over again.\nIt will repeat indefinitely unless `times` is specified.\n\n``` typescript\nimport { repeat } from \"./infinite.ts\";\n\nconst iterable = repeat(\"v\");\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\nv\nv\nv\n(...)\n~~~\n\nHowever, if you specify the second parameter `times` it will repeat that many\ntimes:\n\n``` typescript\nimport { repeat } from \"./infinite.ts\";\n\nconst iterable = repeat(\"V\", 3);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 3 lines:\n\n~~~\nV\nV\nV\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/repeat","deprecated":false,"label":"repeat()"},"take()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"take","file":".","doc":"Takes a specified number of elements from the beginning of an async iterable.\n\n``` typescript\nimport { take } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = take(count(0, 5), 3);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 3 lines:\n\n~~~\n0\n5\n10\n~~~\n\nIf the iterable is shorter than the specified number, the whole elements are\ntaken.\n\n``` typescript\nimport { take } from \"./take.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst iterable = take(gen(), 5);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print only 3 elements, because `gen()` yields only 3\nelements:\n\n~~~\nfoo\nbar\nbaz\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/take","deprecated":false,"label":"take()"},"takeEnd()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"takeEnd","file":".","doc":"Takes a specified number of elements from the end of an async iterable.\n\n``` typescript\nimport { takeEnd } from \"./take.ts\";\nimport { range } from \"./range.ts\";\n\nconst iterable = takeEnd(range(10), 3);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 3 lines:\n\n~~~\n7\n8\n9\n~~~\n\nIf the iterable is shorter than the specified number, the whole elements are\ntaken.\n\n``` typescript\nimport { takeEnd } from \"./take.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst iterable = takeEnd(gen(), 5);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print only 3 elements, because `gen()` yields only 3\nelements:\n\n~~~\nfoo\nbar\nbaz\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/takeEnd","deprecated":false,"label":"takeEnd()"},"takeWhile()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"takeWhile","file":".","doc":"Takes elements from the beginning of an async iterable as long as a specified\ncondition is met.  If the condition is not met, the iterable stops.\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0), v => v < 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n\nAn async `predicate` function also works.  The following example will print\nthe same 4 lines as the previous example:\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0), v => Promise.resolve(v < 4));\nfor await (const value of iterable) console.log(value);\n```\n\nA `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0, 10), (_, i) => i < 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n10\n20\n30\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/takeWhile","deprecated":false,"label":"takeWhile()"},"tee()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"tee","file":".","doc":"","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/tee","deprecated":false,"label":"tee()"},"toArray()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"toArray","file":".","doc":"Creates an array from an async iterable.\n\n``` typescript\nimport { toArray } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst array = await toArray(gen());\n```\n\nThe `array` variable will be an array like `[\"foo\", \"bar\", \"baz\"]`.\n\nNote that its first parameter is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toArray } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\n\nawait toArray(count(0));\n```\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toArray","deprecated":false,"label":"toArray()"},"toMap()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"toMap","file":".","doc":"Creates a map from an async iterable of key-value pairs.  Each pair is\nrepresented as an array of two elements.\n\n``` typescript\nimport { toMap } from \"./collections.ts\";\n\nasync function* gen(): AsyncIterableIterator<[string, number]> {\n  yield [\"foo\", 1]; yield [\"bar\", 2]; yield [\"baz\", 3]; yield [\"qux\", 4];\n}\nconst map = await toMap<string, number>(gen());\n```\n\nThe `map` variable will be a map like `Map { \"foo\" => 1, \"bar\" => 2,\n\"baz\" => 3, \"qux\" => 4 }`.\n\nDuplicate keys are removed except for the last occurrence of each key.  E.g.:\n\n``` typescript\nimport { fromIterable, toMap } from \"./collections.ts\";\n\nconst iterable = fromIterable<[string, number]>([\n  [\"foo\", 1], [\"bar\", 2], [\"baz\", 3], [\"qux\", 4],\n  [\"foo\", 5], [\"bar\", 6],\n]);\nconst map = await toMap<string, number>(iterable);\n```\n\nThe `map` variable will be a map like `Map { \"foo\" => 5, \"bar\" => 6,\n\"baz\" => 3, \"qux\" => 4 }`.\n\nNote that the iterable `source` is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toMap } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\nimport { map } from \"./map.ts\";\n\nawait toMap<number, number>(\n  map((v: number) => [v, v] as [number, number], count(0))\n);\n```\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toMap","deprecated":false,"label":"toMap()"},"toSet()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"toSet","file":".","doc":"Creates a set from an async iterable.\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst set = await toSet(gen());\n```\n\nThe `set` variable will be a set like `new Set([\"foo\", \"bar\", \"baz\"])`.\n\nDuplicate elements are removed except for the first occurrence of each\nelement.  E.g.:\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"foo\"; }\nconst set = await toSet(gen());\n```\n\nThe `set` variable will be a set like `new Set([\"foo\", \"bar\"])`.\n\nNote that the iterable `source` is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\n\nawait toSet(count(0));\n```\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toSet","deprecated":false,"label":"toSet()"},"unique()":{"kind":[{"char":"f","kind":"Function","title":"Function"},{"char":"f","kind":"Function","title":"Function"}],"name":"unique","file":".","doc":"Eliminate duplicates in an async iterable `source`.\n\n``` typescript\nimport { unique } from \"./unique.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"bar\"; yield \"foo\" }\nconst iterable = unique(gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nbar\n~~~\n\nFor complex elements, the `keySelector` function can be used to specify how\nto compare the elements.   Among duplicate elements, the one with the first\noccurrence of the key is kept.  E.g.:\n\n``` typescript\nimport { unique } from \"./unique.ts\";\n\nasync function* gen() {\n  yield { id: 1, name: \"foo\" };\n  yield { id: 2, name: \"bar\" };\n  yield { id: 3, name: \"bar\" };\n  yield { id: 4, name: \"foo\" };\n}\n\nconsole.log(\"Unique by ID:\");\nconst uniqueIds = unique(gen(), v => v.id);\nfor await (const value of uniqueIds) console.log(value);\n\nconsole.log(\"Unique by name:\");\nconst uniqueNames = unique(gen(), v => v.name);\nfor await (const value of uniqueNames) console.log(value);\n```\n\nThe above example will print the following:\n\n~~~\nUnique by ID:\n{ id: 1, name: \"foo\" }\n{ id: 2, name: \"bar\" }\n{ id: 3, name: \"bar\" }\n{ id: 4, name: \"foo\" }\nUnique by name:\n{ id: 1, name: \"foo\" }\n{ id: 2, name: \"bar\" }\n~~~\n","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/unique","deprecated":false,"label":"unique()"}}}