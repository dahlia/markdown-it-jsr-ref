{"package":"@hongminhee/aitertools","version":"0.6.0","index":{"assertStreamStartsWith()":{"kind":["function","function"],"name":"assertStreamStartsWith","file":".","doc":"Makes an assertion that the beginning elements of the `actual` iterable are\nin common with the elements of the `expected` array.\n\n``` typescript\nimport { assertStreamStartsWith } from \"./testing.ts\";\nimport { count } from \"./infinite.ts\";\n\nDeno.test(\"your test name\", async () => {\n  const stream = count(0, 5);\n  await assertStreamStartsWith(stream, [0, 5, 10, 15]);\n});\n```\n","location":{"filename":"testing","line":55,"col":0,"byteIndex":1825},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/assertStreamStartsWith","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"assertStreamStartsWith()"},"assertStreams()":{"kind":["function","function"],"name":"assertStreams","file":".","doc":"Makes an assertion that the elements of the `actual` iterable are equal to\nthe elements of the `expected` array.\n\n``` typescript\nimport { assertStreams } from \"./testing.ts\";\n\nasync function* gen() { yield \"actual\"; yield \"elements\"; }\n\nDeno.test(\"your test name\", async () => {\n  const stream = gen();\n  await assertStreams(stream, [\"actual\", \"elements\"]);\n});\n```\n","location":{"filename":"testing","line":24,"col":0,"byteIndex":790},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/assertStreams","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"assertStreams()"},"concat()":{"kind":["function","function"],"name":"concat","file":".","doc":"Concatenates multiple async iterables into one async iterable.\n\n``` typescript\nimport { concat } from \"./concat.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = concat(gen(), [\"a\", \"b\", \"c\", \"d\"]);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 8 lines:\n\n~~~\nfoo\nbar\nbaz\nqux\na\nb\nc\nd\n~~~\n","location":{"filename":"concat","line":34,"col":0,"byteIndex":952},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/concat","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"concat()"},"count()":{"kind":["function","function"],"name":"count","file":".","doc":"Makes an infinite async iterable of evenly spaced values starting with\nthe `start` number.\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nconst iterable = count(5);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n5\n6\n7\n8\n9\n(...)\n~~~\n\nYou could adjust the interval by passing a second argument to `count()`:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nconst iterable = count(0, 3);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n0\n3\n6\n9\n12\n(...)\n~~~\n\nAs it's infinite, it's usually used with `break` to stop the iteration:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nfor await (const value of count(0)) {\n  if (value > 4) break;\n  console.log(value);\n}\n```\n\nOr with other async generators like `takeWhile()`:\n\n``` typescript\nimport { count } from \"./infinite.ts\";\nimport { takeWhile } from \"./take.ts\";\nfor await (const value of takeWhile(count(0), v => v <= 4)) {\n  console.log(value);\n}\n```\n\nThe both examples above will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n","location":{"filename":"infinite","line":79,"col":0,"byteIndex":1608},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/count","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"count()"},"cycle()":{"kind":["function","function"],"name":"cycle","file":".","doc":"Makes an async iterator that yields elements from the `source` and saving\na copy of each.  When the `source` is exhausted, yields saved copies\nindefinitely.\n\nNote that it may require significant memory to save the copies\ndepending on the length of the `source`.\n\n``` typescript\nimport { cycle } from \"./infinite.ts\";\n\nasync function* gen() { yield 3; yield 6; yield 9; }\nconst iterable = cycle(gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n3\n6\n9\n3\n6\n9\n(...)\n~~~\n","location":{"filename":"infinite","line":136,"col":0,"byteIndex":3000},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/cycle","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"cycle()"},"drop()":{"kind":["function","function"],"name":"drop","file":".","doc":"Drops a specified number of elements from the beginning of an async iterable,\nand yields the remaining elements.\n\n``` typescript\nimport { drop } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = drop(gen(), 2);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbaz\nqux\n~~~\n\nIf the iterable is shorter than or equal to the specified number, no elements\nare yielded.\n\n``` typescript\nimport { drop } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = drop(gen(), 4);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print nothing.\n","location":{"filename":"drop","line":45,"col":0,"byteIndex":1286},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/drop","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"drop()"},"dropEnd()":{"kind":["function","function"],"name":"dropEnd","file":".","doc":"Drops a specified number of elements from the end of an async iterable, and\nyields the remaining elements.\n\n``` typescript\nimport { dropEnd } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropEnd(gen(), 2);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nbar\n~~~\n\nIf the iterable is shorter than or equal to the specified number, no elements\nare yielded.\n\n``` typescript\nimport { dropEnd } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropEnd(gen(), 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print nothing.\n","location":{"filename":"drop","line":180,"col":0,"byteIndex":5414},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/dropEnd","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"dropEnd()"},"dropWhile()":{"kind":["function","function"],"name":"dropWhile","file":".","doc":"Drops elements from the beginning of an async iterable as long as a specified\ncondition is met, and yields the remaining elements.\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), v => v !== \"baz\");\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbaz\nqux\n~~~\n\nAn async `predicate` function also works.  The following example will print\nthe same 2 lines as the previous example:\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), v => Promise.resolve(v !== \"baz\"));\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nA `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { dropWhile } from \"./drop.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = dropWhile(gen(), (_, i) => i % 2 === 0);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 3 lines:\n\n~~~\nbar\nbaz\nqux\n~~~\n","location":{"filename":"drop","line":122,"col":0,"byteIndex":3591},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/dropWhile","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"dropWhile()"},"filter()":{"kind":["function","function"],"name":"filter","file":".","doc":"Eliminates all elements from the iterable `source` that do not satisfy\nthe `predicate` function.\n\n``` typescript\nimport { filter } from \"./filter.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; yield \"qux\" }\nconst iterable = filter((v: string) => !!v.match(/^b/), gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nbar\nbaz\n~~~\n\nThe `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { filter } from \"./filter.ts\";\n\nconst iterable = filter(\n  (v: string, i: number) => !v.match(/^b/) && i % 2 === 0,\n  [\"foo\", \"bar\", \"baz\", \"qux\", \"quux\"]\n);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nquux\n~~~\n","location":{"filename":"filter","line":50,"col":0,"byteIndex":1566},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/filter","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"filter()"},"fromIterable()":{"kind":["function","function"],"name":"fromIterable","file":".","doc":"Turns a synchrnous iterable `source` into an async iterable.\n\n``` typescript\nimport { fromIterable } from \"./collections.ts\";\n\nfunction* iterable() { yield 1; yield 2; yield 3; }\nconst asyncIterable = fromIterable(iterable());\nfor await (const value of asyncIterable) console.log(value);\n```\n\nThe above example will print the following lines:\n\n~~~\n1\n2\n3\n~~~\n","location":{"filename":"collections","line":27,"col":0,"byteIndex":753},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/fromIterable","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"fromIterable()"},"groupBy()":{"kind":["function","function"],"name":"groupBy","file":".","doc":"Groups elmenets of an async interable `source` according to a specified\n`keySelector` function and creates a map of each group key to the elements in\nthat group.  Key values are compared using the `===` operator.\n\n``` typescript\nimport { groupBy } from \"./unique.ts\";\n\ninterface IdName { id: number; name: string; }\nasync function* gen(): AsyncIterableIterator<IdName> {\n  yield { id: 1, name: \"foo\" };\n  yield { id: 2, name: \"bar\" };\n  yield { id: 3, name: \"bar\" };\n  yield { id: 4, name: \"foo\" };\n}\n\nconst map = await groupBy<string, IdName>(gen(), o => o.name);\nconsole.log(map);\n```\n\nThe above example will print the following:\n\n~~~\nMap {\n \"foo\" => [ { id: 1, name: \"foo\" }, { id: 4, name: \"foo\" } ],\n \"bar\" => [ { id: 2, name: \"bar\" }, { id: 3, name: \"bar\" } ]\n}\n~~~\n","location":{"filename":"unique","line":120,"col":0,"byteIndex":3571},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/groupBy","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"groupBy()"},"map()":{"kind":["function","function","function","function","function","function","function","function","function","function","function","function"],"name":"map","file":".","doc":"Transforms every element of the iterable `source` into a new iterable.\n\n``` typescript\nimport { map } from \"./map.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = map((v: number) => v * 2, count());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\n0\n2\n4\n6\n(...)\n~~~\n\nThe `fn` function can take an additional argument, which is the index of the\nelement in the iterable.\n\n``` typescript\nimport { map } from \"./map.ts\";\n\nconst iterable = map(\n  (v: string, i: number) => `${i}. ${v.toUpperCase()}`,\n  [\"foo\", \"bar\", \"baz\", \"qux\"]\n);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0. FOO\n1. BAR\n2. BAZ\n3. QUX\n~~~\n","location":{"filename":"map","line":54,"col":0,"byteIndex":1416},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/map","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"map()"},"range()":{"kind":["function","function","function","function","function","function","function","function","function","function","function","function","function","function"],"name":"range","file":".","doc":"Creates a {@link Range} of numbers from 0 to `stop` with step 1.\n\n``` typescript\nimport { range } from \"./range.ts\";\n\nfor (const value of range(4)) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n\nNote that the type of the range is `Range<number>`, which implements\nboth `Iterable<number>` and `AsyncIterable<number>`.\n","location":{"filename":"range","line":24,"col":0,"byteIndex":466},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/range","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"range()"},"reduce()":{"kind":["function","function","function","function","function","function"],"name":"reduce","file":".","doc":"Apply `reducer` function of two arguments cumulatively to the elements of\nan async iterable `source`, from left to right, so as to reduce the async\niterable to a single value.\n\n``` typescript\nimport { reduce } from \"./fold.ts\";\n\nasync function* oneToFive() { yield 1; yield 2; yield 3; yield 4; yield 5; }\nconst reducedValue = await reduce(\n  (x, y) => { console.log(`${x} + ${y} = ${x + y}`); return x + y; },\n  oneToFive(),\n  0,\n);\nconsole.log(\"reduced value:\", reducedValue);\n```\n\nThe above example will print the following:\n\n~~~\n0 + 1 = 1\n1 + 2 = 3\n3 + 3 = 6\n6 + 4 = 10\n10 + 5 = 15\nreduced value: 15\n~~~\n\nIf the async iterable `source` is empty, the `reducer` function is not\ncalled and `initialValue` is returned.\n\n``` typescript\nimport { reduce } from \"./fold.ts\";\n\nconst reducedValue = await reduce(\n  (x, y) => { console.log(`${x} + ${y} = ${x * y}`); return x * y; },\n  [],\n  1,\n);\nconsole.log(\"reduced value:\", reducedValue);\n```\n\nThe above example will print the following:\n\n~~~\nreduced value: 1\n~~~\n","location":{"filename":"fold","line":63,"col":0,"byteIndex":1992},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/reduce","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"reduce()"},"repeat()":{"kind":["function","function"],"name":"repeat","file":".","doc":"Makes an async iterator that yields the same value over and over again.\nIt will repeat indefinitely unless `times` is specified.\n\n``` typescript\nimport { repeat } from \"./infinite.ts\";\n\nconst iterable = repeat(\"v\");\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following and keep going forever:\n\n~~~\nv\nv\nv\n(...)\n~~~\n\nHowever, if you specify the second parameter `times` it will repeat that many\ntimes:\n\n``` typescript\nimport { repeat } from \"./infinite.ts\";\n\nconst iterable = repeat(\"V\", 3);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 3 lines:\n\n~~~\nV\nV\nV\n~~~\n","location":{"filename":"infinite","line":197,"col":0,"byteIndex":4464},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/repeat","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"repeat()"},"take()":{"kind":["function","function"],"name":"take","file":".","doc":"Takes a specified number of elements from the beginning of an async iterable.\n\n``` typescript\nimport { take } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = take(count(0, 5), 3);\nfor await (const value of iterable) {\n  console.log(value);\n}\n```\n\nThe above example will print the following 3 lines:\n\n~~~\n0\n5\n10\n~~~\n\nIf the iterable is shorter than the specified number, the whole elements are\ntaken.\n\n``` typescript\nimport { take } from \"./take.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst iterable = take(gen(), 5);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print only 3 elements, because `gen()` yields only 3\nelements:\n\n~~~\nfoo\nbar\nbaz\n~~~\n","location":{"filename":"take","line":50,"col":0,"byteIndex":1238},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/take","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"take()"},"takeEnd()":{"kind":["function","function"],"name":"takeEnd","file":".","doc":"Takes a specified number of elements from the end of an async iterable.\n\n``` typescript\nimport { takeEnd } from \"./take.ts\";\nimport { range } from \"./range.ts\";\n\nconst iterable = takeEnd(range(10), 3);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 3 lines:\n\n~~~\n7\n8\n9\n~~~\n\nIf the iterable is shorter than the specified number, the whole elements are\ntaken.\n\n``` typescript\nimport { takeEnd } from \"./take.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst iterable = takeEnd(gen(), 5);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print only 3 elements, because `gen()` yields only 3\nelements:\n\n~~~\nfoo\nbar\nbaz\n~~~\n","location":{"filename":"take","line":185,"col":0,"byteIndex":5072},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/takeEnd","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"takeEnd()"},"takeWhile()":{"kind":["function","function"],"name":"takeWhile","file":".","doc":"Takes elements from the beginning of an async iterable as long as a specified\ncondition is met.  If the condition is not met, the iterable stops.\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0), v => v < 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n1\n2\n3\n~~~\n\nAn async `predicate` function also works.  The following example will print\nthe same 4 lines as the previous example:\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0), v => Promise.resolve(v < 4));\nfor await (const value of iterable) console.log(value);\n```\n\nA `predicate` function can take an index as well as the value.\n\n``` typescript\nimport { takeWhile } from \"./take.ts\";\nimport { count } from \"./infinite.ts\";\n\nconst iterable = takeWhile(count(0, 10), (_, i) => i < 4);\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 4 lines:\n\n~~~\n0\n10\n20\n30\n~~~\n","location":{"filename":"take","line":124,"col":0,"byteIndex":3391},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/takeWhile","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"takeWhile()"},"tee()":{"kind":["function","function","function","function","function","function","function","function","function","function","function","function","function","function","function","function","function","function"],"name":"tee","file":".","doc":"","location":{"filename":"tee","line":3,"col":0,"byteIndex":50},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/tee","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"tee()"},"toArray()":{"kind":["function","function"],"name":"toArray","file":".","doc":"Creates an array from an async iterable.\n\n``` typescript\nimport { toArray } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst array = await toArray(gen());\n```\n\nThe `array` variable will be an array like `[\"foo\", \"bar\", \"baz\"]`.\n\nNote that its first parameter is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toArray } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\n\nawait toArray(count(0));\n```\n","location":{"filename":"collections","line":59,"col":0,"byteIndex":1722},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toArray","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"toArray()"},"toMap()":{"kind":["function","function"],"name":"toMap","file":".","doc":"Creates a map from an async iterable of key-value pairs.  Each pair is\nrepresented as an array of two elements.\n\n``` typescript\nimport { toMap } from \"./collections.ts\";\n\nasync function* gen(): AsyncIterableIterator<[string, number]> {\n  yield [\"foo\", 1]; yield [\"bar\", 2]; yield [\"baz\", 3]; yield [\"qux\", 4];\n}\nconst map = await toMap<string, number>(gen());\n```\n\nThe `map` variable will be a map like `Map { \"foo\" => 1, \"bar\" => 2,\n\"baz\" => 3, \"qux\" => 4 }`.\n\nDuplicate keys are removed except for the last occurrence of each key.  E.g.:\n\n``` typescript\nimport { fromIterable, toMap } from \"./collections.ts\";\n\nconst iterable = fromIterable<[string, number]>([\n  [\"foo\", 1], [\"bar\", 2], [\"baz\", 3], [\"qux\", 4],\n  [\"foo\", 5], [\"bar\", 6],\n]);\nconst map = await toMap<string, number>(iterable);\n```\n\nThe `map` variable will be a map like `Map { \"foo\" => 5, \"bar\" => 6,\n\"baz\" => 3, \"qux\" => 4 }`.\n\nNote that the iterable `source` is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toMap } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\nimport { map } from \"./map.ts\";\n\nawait toMap<number, number>(\n  map((v: number) => [v, v] as [number, number], count(0))\n);\n```\n","location":{"filename":"collections","line":162,"col":0,"byteIndex":5175},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toMap","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"toMap()"},"toSet()":{"kind":["function","function"],"name":"toSet","file":".","doc":"Creates a set from an async iterable.\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"baz\"; }\nconst set = await toSet(gen());\n```\n\nThe `set` variable will be a set like `new Set([\"foo\", \"bar\", \"baz\"])`.\n\nDuplicate elements are removed except for the first occurrence of each\nelement.  E.g.:\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"foo\"; }\nconst set = await toSet(gen());\n```\n\nThe `set` variable will be a set like `new Set([\"foo\", \"bar\"])`.\n\nNote that the iterable `source` is assumed to be finite; otherwise, it will\nnever return.  The following example will never return:\n\n``` typescript\nimport { toSet } from \"./collections.ts\";\nimport { count } from \"./infinite.ts\";\n\nawait toSet(count(0));\n```\n","location":{"filename":"collections","line":104,"col":0,"byteIndex":3136},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/toSet","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"toSet()"},"unique()":{"kind":["function","function"],"name":"unique","file":".","doc":"Eliminate duplicates in an async iterable `source`.\n\n``` typescript\nimport { unique } from \"./unique.ts\";\n\nasync function* gen() { yield \"foo\"; yield \"bar\"; yield \"bar\"; yield \"foo\" }\nconst iterable = unique(gen());\nfor await (const value of iterable) console.log(value);\n```\n\nThe above example will print the following 2 lines:\n\n~~~\nfoo\nbar\n~~~\n\nFor complex elements, the `keySelector` function can be used to specify how\nto compare the elements.   Among duplicate elements, the one with the first\noccurrence of the key is kept.  E.g.:\n\n``` typescript\nimport { unique } from \"./unique.ts\";\n\nasync function* gen() {\n  yield { id: 1, name: \"foo\" };\n  yield { id: 2, name: \"bar\" };\n  yield { id: 3, name: \"bar\" };\n  yield { id: 4, name: \"foo\" };\n}\n\nconsole.log(\"Unique by ID:\");\nconst uniqueIds = unique(gen(), v => v.id);\nfor await (const value of uniqueIds) console.log(value);\n\nconsole.log(\"Unique by name:\");\nconst uniqueNames = unique(gen(), v => v.name);\nfor await (const value of uniqueNames) console.log(value);\n```\n\nThe above example will print the following:\n\n~~~\nUnique by ID:\n{ id: 1, name: \"foo\" }\n{ id: 2, name: \"bar\" }\n{ id: 3, name: \"bar\" }\n{ id: 4, name: \"foo\" }\nUnique by name:\n{ id: 1, name: \"foo\" }\n{ id: 2, name: \"bar\" }\n~~~\n","location":{"filename":"unique","line":63,"col":0,"byteIndex":1848},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/unique","category":"","declarationKind":"export","deprecated":false,"members":[],"label":"unique()"},"Range":{"kind":["class","class"],"name":"Range","file":".","doc":"An immutable sequence of numbers.  It implements both `Iterable` and\n`AsyncIterable`.\n\nIt is similar to Python's `range()` function.","location":{"filename":"range","line":185,"col":0,"byteIndex":4383},"url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range","category":"","declarationKind":"export","deprecated":false,"members":[{"kind":"constructor","index":0},{"kind":"accessor","name":"length"},{"kind":"property","name":"start"},{"kind":"property","name":"step"},{"kind":"property","name":"stop"},{"kind":"method","name":"[Symbol.asyncIterator]","index":0,"static":false},{"kind":"method","name":"[Symbol.iterator]","index":0,"static":false},{"kind":"method","name":"at","index":0,"static":false},{"kind":"method","name":"toString","index":0,"static":false}],"label":"Range"},"new Range()":{"kind":"constructor","index":0,"label":"new Range()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range#constructor_0"},"Range.length":{"kind":"accessor","name":"length","label":"Range.length","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length"},"~Range.length":{"kind":"accessor","name":"length","label":"length","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.length"},"Range.start":{"kind":"property","name":"start","label":"Range.start","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.start"},"~Range.start":{"kind":"property","name":"start","label":"start","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.start"},"Range.step":{"kind":"property","name":"step","label":"Range.step","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.step"},"~Range.step":{"kind":"property","name":"step","label":"step","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.step"},"Range.stop":{"kind":"property","name":"stop","label":"Range.stop","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.stop"},"~Range.stop":{"kind":"property","name":"stop","label":"stop","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.stop"},"Range.[Symbol.asyncIterator]()":{"kind":"method","name":"[Symbol.asyncIterator]","index":0,"static":false,"label":"Range.[Symbol.asyncIterator]()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]"},"~Range.[Symbol.asyncIterator]()":{"kind":"method","name":"[Symbol.asyncIterator]","index":0,"static":false,"label":"[Symbol.asyncIterator]()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.asyncIterator]"},"Range.[Symbol.iterator]()":{"kind":"method","name":"[Symbol.iterator]","index":0,"static":false,"label":"Range.[Symbol.iterator]()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]"},"~Range.[Symbol.iterator]()":{"kind":"method","name":"[Symbol.iterator]","index":0,"static":false,"label":"[Symbol.iterator]()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.[Symbol.iterator]"},"Range.at()":{"kind":"method","name":"at","index":0,"static":false,"label":"Range.at()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at"},"~Range.at()":{"kind":"method","name":"at","index":0,"static":false,"label":"at()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.at"},"Range.toString()":{"kind":"method","name":"toString","index":0,"static":false,"label":"Range.toString()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString"},"~Range.toString()":{"kind":"method","name":"toString","index":0,"static":false,"label":"toString()","url":"https://jsr.io/@hongminhee/aitertools@0.6.0/doc/~/Range.prototype.toString"}}}